#!/usr/bin/env python3
# Kawariki -- NW.js game compat tool
# ------------------------------------------------------------------
# Copyright (C) 2021 Taeyeon Mori <taeyeon at oro dot sodimm dot me>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# ------------------------------------------------------------------
# Please note that files generated or otherwise handled by this tool
# are covered by their respective third-party licenses.
# Content generated in whole by the tool without being derived from
# third-party distributions shall be in the public domain under CC0.

import abc
import argparse
import enum
import errno
import functools
import io
import json
import os
import pathlib
import re
import shlex
import shutil
import subprocess
import sys
import tarfile
import tempfile
import textwrap
from typing import Optional, Tuple
import urllib.request


__version__ = "1.0"


builtin_print = print

def print(*messages, **opts):
    if "file" not in opts:
        opts["file"] = sys.stderr
    return builtin_print("[Kawariki]", *messages, **opts)


# :---------------------------------------------------------------------------:
#   UI
# :---------------------------------------------------------------------------:
class MsgType(enum.Enum):
    Error = 0
    Warn = 1
    Info = 2


def _setter_only(fn):
        return property(None, fn)


try:
    import tkinter.messagebox
    import tkinter.ttk
except ImportError:
    HAVE_TK = False
else:
    HAVE_TK = True

    class TkGui:
        def show_msg(self, type, title, message):
            self._root # hide tk root window
            {
                MsgType.Error: tkinter.messagebox.showerror,
                MsgType.Warn: tkinter.messagebox.showwarning,
                MsgType.Info: tkinter.messagebox.showinfo,
            }[type](title, message)

        class ProgressDialog(tkinter.Toplevel):
            def __init__(self, title, text, progress=0, maximum=100):
                super().__init__(None)#tkinter._get_default_root('create dialog window'))
                self.withdraw()
                self.title(title)
                #self.wm_attributes("-type", "dialog")
                self.body = tkinter.Frame(self)
                self.body.pack(padx=5, pady=5)
                self.label = tkinter.Label(self.body, text=text)
                self.label.grid(row=0, column=0)
                self.progress_var = tkinter.DoubleVar(value=progress)
                self.progress_bar = tkinter.ttk.Progressbar(self.body, variable=self.progress_var, maximum=maximum, length=600)
                self.progress_bar.grid(row=1, column=0)

            def __enter__(self):
                self.deiconify()
                self.body.focus_set()
                self.grab_set()
                self._update()
                return self

            def __exit__(self, et, v, tb):
                self._update()
                self.withdraw()
                self.destroy()

            def _update(self):
                self.update()
                self.update_idletasks()

            @property
            def progress(self):
                return self.progress_var.get()

            @progress.setter
            def progress(self, progress):
                self.progress_var.set(progress)
                self._update()

            @_setter_only
            def text(self, text):
                self.label.configure(text=text)
                self._update()

            @_setter_only
            def maximum(self, max):
                self.progress_bar.configure(maximum=max)
                self._update()

        @property
        def _root(self):
            self.__dict__["_root"] = root = tkinter.Tk()
            root.withdraw()
            root.update()
            return root

        def destroy(self):
            if "_root" in self.__dict__:
                self._root.destroy()
                del self.__dict__["_root"]

        def show_progress(self, *args, **kwds):
            self._root # Make sure root is hidden
            return self.ProgressDialog(*args, **kwds)


class ZenityGui:
    def __init__(self, prog):
        self.prog = prog

    def show_msg(self, type, title, message):
        types = {
            MsgType.Error: "--error",
            MsgType.Warn: "--warning",
            MsgType.Info: "--info",
        }
        subprocess.check_call([self.prog, types[type], "--title", title, "--text", message])

    class ProgressDialog:
        def __init__(self, prog, /, title, text, progress=0, maximum=100):
            self.prog = prog
            self.title = title
            self._text = text
            self._progress = progress
            self.maximum = maximum
            self.proc = None

        @property
        def percentage(self):
            return self._progress / self.maximum * 100

        def __enter__(self):
            self.proc = subprocess.Popen([self.prog, "--progress", "--title", self.title, "--text", self._text, "--percentage", f"{self.percentage:.0f}"], stdin=subprocess.PIPE)
            return self

        def __exit__(self, t, e, tb):
            self.proc.stdin.close()
            self.proc.wait()

        @property
        def progress(self):
            return self._progress

        @progress.setter
        def progress(self, progress):
            self._progress = progress
            if self.proc:
                self.proc.stdin.write(f"{self.percentage:.0f}\n".encode("utf-8"))
                self.proc.stdin.flush()

        @property
        def text(self):
            return self._text

        @text.setter
        def text(self, text):
            self._text = text
            if self.proc:
                self.proc.stdin.write(f"#{text}\n".encode("utf-8"))
                self.proc.stdin.flush()

    def show_progress(self, *args, **kwds):
        return self.ProgressDialog(self.prog, *args, **kwds)


class KDialogGui:
    def __init__(self, prog):
        self.prog = prog

    def show_msg(self, type, title, message):
        types = {
            MsgType.Error: "--error",
            MsgType.Warn: "--warn",
            MsgType.Info: "--info",
        }
        return subprocess.check_call([self.prog, "--title", title, types[type], message])


class DummyProgress:
    def __init__(self, title, text, progress=0, maximum=100):
        self.title = title
        self.text = text
        self.progress = progress
        self.maximum = maximum

    def __enter__(self):
        return self

    def __exit__(self, t, e, tb):
        pass


# :---------------------------------------------------------------------------:
#   Support
# :---------------------------------------------------------------------------:
def create_gui():
    specified = os.environ.get("MVWRAPPER_GUI", "").lower()
    if HAVE_TK and specified in ("", "tk", "tkinter"):
        return TkGui()
    elif (prog := shutil.which("zenity")) and specified in ("", "zenity"):
        return ZenityGui(prog)
    elif (prog := shutil.which("kdialog")) and specified in ("", "kdialog"):
        return KDialogGui(prog)

if sys.version_info < (3, 8):
    # functools.cached_property, possibly others
    # Try to provide an easily understood error message instead of failing later
    if gui := create_gui():
        gui.show_msg(MsgType.Error, "RMMV NW.js Runtime requires more recent Python", f"Python 3.8 or later is required, but currently running:\nPython {sys.version}")

    raise ImportError("Unsupported python version {}.{}.{}{}{}. At least 3.8 is required.".format(*sys.version_info))

def version_str(ver: tuple):
    return '.'.join(map(str, ver))


class Runtime:
    def __init__(self, toolpath=os.path.dirname(sys.argv[0])):
        self.base           = pathlib.Path(toolpath).resolve()
        self.overlayns_bin  = self.base / "overlayns-static"

    # +-------------------------------------------------+
    # NW.js versions
    # +-------------------------------------------------+
    @functools.cached_property
    def nwjs_versions(self):
        with open(self.base / "nwjs-versions.json") as f:
            return [self.NWjs(i, self.base) for i in json.load(f)]

    def get_nwjs(self, version_name):
        for ver in self.nwjs_versions:
            if ver.name == version_name:
                return ver

    def get_nwjs_version(self, min=None, max=None, sdk=None):
        """
        Get the latest NW.js version available matching the requirements

        :param min: Minimum version (inclusive)
        :param max: Maximum version (inclusive)
        :param sdk: Require DevTools-enabled distribution
        """
        if v := sorted([ver for ver in self.nwjs_versions
                            if  (min is None or min <= ver.version)
                            and (max is None or max >= ver.version)
                            and (not sdk or ver.has("sdk"))],
                        key=lambda ver: (ver.version, ver.available, not ver.has("sdk"))):
            return v[-1]

    class NWjs:
        def __init__(self, info, path):
            self._path = path
            self.info = info

        @property
        def version(self):
            return tuple(self.info["version"])

        @property
        def name(self):
            return self.info.get("name", self.dist)

        @property
        def dist(self):
            return self.info["dist"]

        def get_path(self, component) -> pathlib.Path:
            return self._path / self.info[component]

        def has(self, component):
            return bool(self.info.get(component, None))

        @property
        def binary(self):
            return self.get_path("dist") / "nw"

        @property
        def available(self):
            return self.get_path("dist").exists()

        def __repr__(self):
            return f"<Runtime.NWjs {version_str(self.version)} '{self.dist}' at 0x{id(self):x}>"

    # +-------------------------------------------------+
    # Error reporting
    # +-------------------------------------------------+
    def stderr_show_msg(self, type, title, message):
        colors = {
            MsgType.Error: 31,
            MsgType.Warn: 36,
            MsgType.Info: 34,
        }
        print(f"\033[{colors[type]}m{title}\033[0m:" if sys.stderr.isatty() else f"{title}:", file=sys.stderr)
        for l in message.split('\n'):
            print('\t', l, file=sys.stderr)

    @functools.cached_property
    def gui(self):
        return create_gui()

    def show_msg(self, type, title, message):
        self.stderr_show_msg(type, title, message)
        if self.gui:
            self.gui.show_msg(type, title, message)

    def show_error(self, message, title="RMMV NW.js Runtime Error"):
        self.show_msg(MsgType.Error, title, message)

    def show_warn(self, message, title="RMMV NW.js Runtime Warning"):
        self.show_msg(MsgType.Warn, title, message)

    def show_info(self, message, title="RMMV NW.js Runtime"):
        self.show_msg(MsgType.Info, title, message)

    def show_progress(self, text, progress=0, maximum=100, title="RMMV NW.js Runtime"):
        if self.gui and hasattr(self.gui, "show_progress"):
            return self.gui.show_progress(title, text, progress, maximum)
        else:
            return DummyProgress(title, text, progress, maximum)


class Game:
    root: pathlib.Path

    def __init__(self, game_root: pathlib.Path):
        self.root = game_root

    # +-------------------------------------------------+
    # RPGMaker detection
    # +-------------------------------------------------+
    RPGMAKER_INFO_RE = re.compile(r'''Utils.RPGMAKER_(VERSION|NAME)\s*\=\s*["']([^"']+)["']''')

    @functools.cached_property
    def rpgmaker_info(self) -> "Optional[Tuple[str, Tuple]]":
        # Find RPGMaker core file
        # MV: rpg_core.js, MZ: rmmz_core.js
        for rpgcore in self.root.rglob("r*_core.js"):
            with open(rpgcore, "r") as f:
                kind = version = None
                for l in f:
                    if m := self.RPGMAKER_INFO_RE.search(l):
                        if m.group(1) == "VERSION" :
                            version = tuple(int(x) for x in m.group(2).split('.'))
                        elif m.group(1) == "NAME":
                            kind = m.group(2)
                        if version is not None and kind is not None:
                            return kind, version

    @property
    def rpgmaker_release(self) -> "Optional[str]":
        if i := self.rpgmaker_info:
            return i[0]

    @property
    def rpgmaker_version(self) -> "Optional[Tuple]":
        if i := self.rpgmaker_info:
            return i[1]

    @property
    def is_rpgmaker(self) -> bool:
        return self.rpgmaker_info is not None

    @property
    def is_rpgmaker_mv_legacy(self) -> "Optional[bool]":
        # Check for old RPGMaker MV version
        if i := self.rpgmaker_info:
            return i[0] == "MV" and i[1] < (1, 6)

    # +-------------------------------------------------+
    # Finding NW.js package.json
    # +-------------------------------------------------+
    @functools.cached_property
    def package_json(self) -> "Optional[pathlib.Path]":
        if (p := self.root / "package.json").exists():
            return p
        elif (p := self.root / "www" / "package.json").exists():
            return p
        else:
            # Try to find package.json
            for p in self.root.rglob("package.json"):
                print(f"Using non-standard package.json location {p}", file=sys.stderr)
                return p

    @property
    def package_dir(self) -> "Optional[pathlib.Path]":
        """ Directory containing package.json, relative to game root """
        if pkg := self.package_json:
            return pkg.parent.relative_to(self.root)


# :---------------------------------------------------------------------------:
#   Run NW.js for Game
# :---------------------------------------------------------------------------:
def try_download_nwjs(r: Runtime, nwjs: Runtime.NWjs):
    if not nwjs.has("dist_url"):
        r.show_error(f"Cannot download NW.js distribution '{nwjs.dist}'\nnwjs-versions.json doesn't specify a download url.")
        return 8
    progress_header = f"Downloading NW.js distribution '{nwjs.dist}'"
    with r.show_progress(f"{progress_header}\n\nConnecting") as p:
        try:
            with urllib.request.urlopen(nwjs.info["dist_url"]) as f:
                f: urllib.response.addinfourl
                p.maximum = int(f.info().get("content-length", 0))
                with tarfile.open(mode="r|*", fileobj=f, encoding="utf-8") as tar:
                    tar: tarfile.TarFile
                    dest = nwjs.get_path("dist")
                    dest.mkdir()
                    while info := tar.next():
                        info: tarfile.TarInfo
                        # Figure out filename, strip prefix
                        # there isn't really a good way of figuring out a common prefix in stream mode
                        # so just strip the leading path component if it starts with nwjs- for now
                        if '/' in info.name:
                            dir, name = info.name.split("/", 1)
                            if dir.startswith("nwjs-"):
                                info.name = name
                        p.text = f"{progress_header}\n\nExtracting '{info.name}'"
                        p.progress = info.offset
                        tar.extract(info, dest)
        except urllib.request.URLError as e:
            r.show_error(f"Could not connect to '{nwjs.info['dist_url']}':\n{e.reason}")
            return 9
        except:
            import traceback
            r.show_error(f"Error downloading NW.js distribution:\n\n{traceback.format_exc()}")
            shutil.rmtree(nwjs.get_path("dist"), ignore_errors=True)
            return 10
    r.show_info(f"Finished downloading NW.js distribution '{nwjs.dist}'")


def copy_unlink(src, dst):
    # Unlink first to be able to overwrite write-protected files
    if os.path.exists(dst):
        os.unlink(dst)
    return shutil.copy2(src, dst)


def select_nwjs_version(r: Runtime, game: Game, nwjs_name: str=None, sdk=False) -> Runtime.NWjs:
    nwjs = None
    if nwjs_name is not None:
        if (nwjs := r.get_nwjs(nwjs_name)) is None:
            r.show_error(f"Specified NW.js version '{nwjs_name}' doesn't exist. Check nwjs-versions.json")
            return 5
        else:
            print(f"Using specified NW.js version '{nwjs_name}' ({nwjs.dist})", file=sys.stderr)

    if game.is_rpgmaker:
        print(f"Looks like RPGMaker {game.rpgmaker_release} {version_str(game.rpgmaker_version)}", file=sys.stderr)

        if game.is_rpgmaker_mv_legacy:
            if nwjs is not None:
                if nwjs.version >= (0, 13):
                    r.show_warn(f"Overriding NW.js version for legacy RMMV (before 1.6) game.\nSelected version is {nwjs.version}, but legacy RMMV may only work correctly with NW.js up to 0.12.x")
            else:
                print("Using NW.js suitable for legacy RMMV (before 1.6)", file=sys.stderr)
                nwjs = r.get_nwjs_version(max=(0, 12, 99))
                if nwjs is None:
                    r.show_error("No NW.js version suitable for RMMV before 1.6 found (requires NW.js older than 0.13)\nYou can force an incompatible version using --nwjs, but YMMV")
                    return 5

    if nwjs is None:
        if (nwjs := r.get_nwjs_version(min=(0, 13), sdk=sdk)) is None:
            r.show_error("No suitable NW.js version found in nwjs-versions.json")
            return 6
        else:
            print(f"Selected NW.js version: {nwjs.dist}", file=sys.stderr)
    
    return nwjs


def select_and_download_nwjs(r: Runtime, game: Game, nwjs_name: str=None, sdk=False) -> Runtime.NWjs:
    # Select nwjs version
    nwjs = select_nwjs_version(r, game, nwjs_name, sdk)
    if isinstance(nwjs, int):
        return nwjs

    # Download NW.js version
    if not nwjs.available:
        if res := try_download_nwjs(r, nwjs):
            return res

    if not os.access(nwjs.binary, os.X_OK|os.F_OK):
        r.show_error(f"Entry '{nwjs.name}' in nwjs-versions.json is broken:\n'{nwjs.binary}' doesn't exist")
        return 6
    
    return nwjs


def try_run_nwjs(game_path: str, arguments: list[str], nwjs_name=None, dry=False, sdk=None):
    # Make sure to convert backslashes
    if '\\' in str(game_path):
        game_path = pathlib.PureWindowsPath(game_path).as_posix()

    game_root = pathlib.Path(game_path).resolve()
    if not game_root.is_dir():
        game_root = game_root.parent

    # Setup paths
    r = Runtime()
    game = Game(game_root)

    # Get suitable NW.js distro
    nwjs = select_and_download_nwjs(r, game, nwjs_name, sdk)
    if isinstance(nwjs, int):
        return nwjs

    # Patch some game files
    tempdir = None
    overlayns = []

    # Patch native greenworks (Steamworks API)
    # Use some namespace magic to leave the game install clean
    # This requires unprivileged user namespaces to be enabled in the kernel
    # In some versions of Ubuntu/Debian it can be enabled with 'sysctl -w kernel.unprivileged_userns_clone=1'
    for path in game.root.rglob("greenworks.js"):
        if not nwjs.has("greenworks"):
            r.show_warn(f"Greenworks not available on NW.js version '{nwjs.name}' ({nwjs.dist})")
            break
        print(f"Patching Greenworks at '{path}'", file=sys.stderr)
        ppath = path.parent
        # Unfortunately, overlayfs is currently incompatible with casefolding-enabled ext4.
        # Steam libraries are very likely to be on such a filesystem though.
        #overlayns.append("-o")
        #overlayns.append("{},shadow,lowerdir={},nodev,nosuid".format(ppath,r.nwjs_greenworks_path))
        # Instead, fall back to copies and bind mounts
        if tempdir is None:
            tempdir = tempfile.TemporaryDirectory()
        xpath = pathlib.Path(tempdir.name) / str(ppath.relative_to(game.root)).replace("/", "_")
        if ',' in str(ppath) or ',' in str(xpath):
            r.show_error("Comma in paths is currently not supported by overlayns\nGreenworks support disabled")
            continue
        shutil.copytree(ppath, xpath)
        shutil.copytree(nwjs.get_path("greenworks"), xpath, dirs_exist_ok=True, copy_function=copy_unlink)
        overlayns.append("-m")
        overlayns.append(f"bind,{xpath},{ppath}")

    env = os.environ.copy()

    if not game.package_json:
        r.show_error(f"{game.root}\ndoesn't look like a RPGMaker MV/MZ (or other NW.js) game")
        return 3

    argv = [nwjs.binary, game.package_dir, *arguments]

    if overlayns:
        argv = [r.overlayns_bin, *overlayns, *argv]

    print(f"Running {shlex.join(map(str, argv))} in {game.root}", file=sys.stderr)

    # Try to clean up some resources
    if hasattr(r.gui, "destroy"):
        r.gui.destroy()

    # FIXME: differentiate between overlayns and game/nwjs failure
    #        and offer to re-try without overlaynw/greenworks support
    if not dry:
        subprocess.check_call(argv, cwd=game.root, env=env)

    if tempdir:
        tempdir.cleanup()

    return 0


def add_launcher(args):
    game_root = pathlib.Path(args.game).resolve()
    if not game_root.is_dir():
        game_root = game_root.parent

    r = Runtime()
    game = Game(game_root)

    nwjs = select_and_download_nwjs(r, game, args.nwjs, args.sdk)
    if isinstance(nwjs, int):
        return nwjs
    
    selfpath = (r.base / pathlib.Path(sys.argv[0]).name).resolve()
    
    path = game_root / args.launcher
    with open(path, "w") as f:
        f.write(Patcher.format_launcher(selfpath, "run", "--", "."))
    os.chmod(path, 0o755)
    
    print(f"Created launcher '{path}'")
    
    return 0


# :---------------------------------------------------------------------------:
#   Patch game install
# :---------------------------------------------------------------------------:
class PatcherOut:
    def __enter__(self):
        return self

    @abc.abstractmethod
    def add_file(self, dstname: str, src: pathlib.Path):
        pass

    @abc.abstractmethod
    def write_file(self, dstname: str, content: bytes):
        pass

    def skip_file(self, dstname: str):
        pass

    def __exit__(self, t, e, tb):
        pass

class PatcherToCopy(PatcherOut):
    def __init__(self, path: pathlib.Path, copy_function=shutil.copy2):
        self.path = path
        self.copy_function = copy_function
    
    def add_file(self, dstname, src):
        dstpath = self.path / dstname
        if not dstpath.exists() or not os.path.samefile(dstpath, src):
            dstpath.parent.mkdir(parents=True, exist_ok=True)
            self.copy_function(src, dstpath)
    
    def write_file(self, dstname, content, mode=0o644):
        dstpath = self.path / dstname
        if dstpath.exists():
            os.unlink(dstpath)
        else:
            dstpath.parent.mkdir(parents=True, exist_ok=True)
        with open(dstpath, "xb") as f:
            f.write(content)
        os.chmod(dstpath, mode)

class PatcherInPlace(PatcherToCopy):
    def skip_file(self, dstname: str):
        os.unlink(self.path / dstname)

class PatcherToTar(PatcherOut):
    def __init__(self, path: pathlib.Path):
        if path.suffix in (".gz", ".bz2", ".xz"):
            self._mode = f"x:{path.suffix[1:]}"
            if path.suffixes[-2] != ".tar":
                raise ValueError(f"Only tar archive output supported, not {path.suffixes[-2]}")
        elif path.suffix in (".tgz", ".tbz2", ".txz"):
            self._mode = f"x:{path.suffix[2:]}"
        elif path.suffix == ".tar":
            self._mode = "x"
        else:
            raise ValueError(f"Only tar archive output supported, not {path.suffix}")
        self.path = path
        self.tar = None
    
    def __enter__(self):
        self.tar = tarfile.TarFile(self.path, self._mode).__enter__()
        return self
    
    def add_file(self, dstname, src):
        self.tar.add(src, dstname, False)
    
    def write_file(self, dstname, content: bytes, mode=0o644):
        i = tarfile.TarInfo(name=dstname)
        i.size = len(content)
        i.mode = mode
        self.tar.addfile(i, io.BytesIO(content))
    
    def __exit__(self, t, e, tb):
        tar = self.tar
        self.tar = None
        return tar.__exit__(t, e, tb)


class Patcher:
    def __init__(self, nwjs: Runtime.NWjs):
        self.nwjs = nwjs

    @classmethod
    def filename_filter(cls, path: pathlib.PurePath):
        return not (path.parent.name in ("swiftshader", "locales")
                or  path.name in ("nw_100_percent.pak", "nw_200_percent.pak", "resources.pak",
                                "natives_blob.bin", "snapshot_blob.bin", "v8_context_snapshot.bin", "icudtl.dat")
                or  path.suffix in (".dll", ".exe", ".lib", ".node"))
    
    @classmethod
    def patch_filter(cls, path: pathlib.PurePath):
        return path.name in ("greenworks.js",)

    def add_game_files(self, dst: PatcherOut, src: pathlib.Path):
        patches = []
        for root, _, files in os.walk(src):
            root = pathlib.Path(root)
            rroot = root.relative_to(src)
            for fname in files:
                rpath = rroot / fname
                if self.patch_filter(rpath):
                    patches.append(rpath)
                elif self.filename_filter(rpath):
                    self.add_file(dst, rpath, root / fname)
                else:
                    self.skip_file(dst, rpath)
        return patches
    
    def add_file(self, dst: PatcherOut, dstname, srcpath):
        print(f"Adding file   '{dstname}'")
        dst.add_file(dstname, srcpath)

    def skip_file(self, dst: PatcherOut, dstname):
        print(f"Skipping file '{dstname}'")
        dst.skip_file(dstname)

    def add_files_from_list(self, dst: PatcherOut, dstpath, srcpath, flist):
        for fname in flist:
            self.add_file(dst, dstpath / fname, srcpath / fname)

    def add_patched(self, dst: PatcherOut, patches):
        for rpath in patches:
            if rpath.name == "greenworks.js":
                self.add_greenworks(dst, rpath)
            else:
                raise ValueError(f"No patch available for {rpath}")
    
    def add_greenworks(self, dst: PatcherOut, rpath):
        if not self.nwjs.has("greenworks"):
            raise ValueError(f"Selected NW.js {self.nwjs.dist} doesn't have Greenworks support")
        gw_path = self.nwjs.get_path("greenworks")
        for root, _, files in os.walk(gw_path):
            root = pathlib.Path(root)
            self.add_files_from_list(dst, rpath.parent / root.relative_to(gw_path), root, files)
    
    def add_nwjs(self, dst: PatcherOut):
        nw_path = self.nwjs.get_path("dist")
        for root, _, files in os.walk(nw_path):
            root = pathlib.Path(root)
            self.add_files_from_list(dst, root.relative_to(nw_path.parent), root, files)
    
    @staticmethod
    def format_launcher(*args, append_args=True):
        return textwrap.dedent(f'''\
            #!/bin/sh
            cd "`dirname "$0"`"
            exec {shlex.join(map(str, args))}{' "$0"' if append_args else ""}
            ''')
    
    def add_launcher(self, dst: PatcherOut, game: Game):
        print("Adding launcher script 'Game.sh'")
        dst.write_file("Game.sh", self.format_launcher(self.nwjs.dist / "nw", game.package_dir).encode("utf-8"), mode=0o755)
    
    def run(self, dst: PatcherOut, game: Game):
        with dst:
            patches = self.add_game_files(dst, game.root)
            self.add_patched(dst, patches)
            self.add_nwjs(dst)
            self.add_launcher(dst, game)


def hardlink_or_copy(src, dst):
    try:
        os.link(src, dst)
    except OSError as e:
        if e.errno != errno.EXDEV:
            raise
    else:
        return
    shutil.copy2(src, dst)


def try_patch_game(args):
    game_root = pathlib.Path(args.game).resolve()
    if not game_root.is_dir():
        game_root = game_root.parent

    r = Runtime()
    game = Game(game_root)

    nwjs = select_and_download_nwjs(r, game, args.nwjs, args.sdk)
    if isinstance(nwjs, int):
        return nwjs

    if args.archive:
        out = PatcherToTar(args.archive)
    elif args.dest:
        out = PatcherToCopy(args.dest)
    elif args.link_dest:
        out = PatcherToCopy(args.link_dest, hardlink_or_copy)
    elif args.inplace:
        out = PatcherInPlace(game_root)
    else:
        assert 0
    
    p = Patcher(nwjs)
    p.run(out, game)
    
    return 0


# :---------------------------------------------------------------------------:
#   Main
# :---------------------------------------------------------------------------:
def add_common_args(parser: argparse.ArgumentParser, *, gamepath=True, nwjs=True, sdk=True):
    if gamepath:
        parser.add_argument("game", help="Path of the game directory or executable", type=pathlib.Path)
    if sdk:
        parser.add_argument("-d", "--sdk", action="store_true", help="Select a NW.js version with DevTools support")
    if nwjs:
        parser.add_argument("--nwjs", help="Use specified NW.js version from 'nwjs-versions.json'")

def main(argv):
    parser = argparse.ArgumentParser(prog=argv[0], description="""\
    Kawariki is a Steam Play compatible tool for running NW.js-based games using
    different (usually newer) versions of NW.js than they shipped with.
    This includes running games that only have a Windows build on a linux-native version.
    Support for patching Greenworks natives is included.""",
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("--version", action="version",
            version=f"Kawariki {__version__}, running on Python {version_str(sys.version_info)}")
    sub = parser.add_subparsers(dest="action")
    add_sub_parser = lambda name, help=None: sub.add_parser(name, help=help, description=help)
    run = add_sub_parser("run", help="Run a NW.js based game on a different NW.js version")
    add_common_args(run)
    run.add_argument("--wait", action="store_true")
    run.add_argument("--dry", action="store_true", help="Only print the resulting command, don't run the game")
    run.add_argument("game_args", metavar="game args", nargs="*", help="Pass additional arguments to the game")
    fixpath = add_sub_parser("fixpath")
    fixpath.add_argument("path")
    patchgame = add_sub_parser("patch", help="Create a patched version of a NW.js game with a different version baked in")
    add_common_args(patchgame)
    patchgame_out = patchgame.add_argument_group("destination options").add_mutually_exclusive_group(required=True)
    patchgame_out.add_argument("-a", "--archive", help="Create an archive file", type=pathlib.Path)
    patchgame_out.add_argument("-o", "--dest", help="Store patched game in this directory", type=pathlib.Path)
    patchgame_out.add_argument("--link-dest", help="Store patched game in this directory, use hard links to save space",
            type=pathlib.Path)
    patchgame_out.add_argument("--inplace", action="store_true", help="Modify the game in place")
    create_launcher = add_sub_parser("launcher", help="Add a launcher script to the game directory")
    add_common_args(create_launcher)
    create_launcher.add_argument("launcher", help="Filename of the launcher to create [%(default)s]", default="Game.sh", nargs="?")
    args = parser.parse_args(argv[1:])

    print(f"v{__version__}, python {version_str(sys.version_info)}; {shlex.join(argv[1:])}", file=sys.stderr)

    if args.action == "run":
        # Skip install scripts. Also ignore --wait for now
        if args.game.name == "iscriptevaluator.exe":
            print("Skipping iscriptevaluator.exe invocation", file=sys.stderr)
            return 0
        return try_run_nwjs(args.game, args.game_args, nwjs_name=args.nwjs, dry=args.dry, sdk=args.sdk)
    elif args.action == "fixpath":
        # Running native NW.js, try to strip out any backslashes that may have slipped in
        print(f"Convert path: {args.path}", file=sys.stderr)
        sys.stdout.buffer.write(pathlib.PureWindowsPath(args.path).as_posix().encode("utf-8"))
        return 0
    elif args.action == "patch":
        return try_patch_game(args)
    elif args.action == "launcher":
        return add_launcher(args)
    else:
        print("Need a verb")
        return 1

if __name__ == "__main__":
    sys.exit(main(sys.argv))
